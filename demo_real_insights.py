"""
Real AWS Insights Demo - Using StrandKit to analyze your infrastructure

This demonstrates how StrandKit tools provide actual value for debugging and monitoring.
"""

import sys
import os
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from strandkit.tools.cloudwatch import get_lambda_logs, get_metric
from datetime import datetime


def health_check_dashboard():
    """Generate a health dashboard for Lambda functions"""

    print("=" * 80)
    print("  AWS Lambda Health Dashboard")
    print("  Generated by StrandKit")
    print("=" * 80 + "\n")

    functions = [
        "veridano-admin-dashboard",
        "veridano-enhanced-mcp-tools",
        "veridano-public-mcp-server",
        "veridano-webhook-manager",
        "veridano-data-validation",
    ]

    health_data = []

    for func in functions:
        # Get invocation metrics (last 6 hours)
        invocations = get_metric(
            namespace="AWS/Lambda",
            metric_name="Invocations",
            dimensions={"FunctionName": func},
            statistic="Sum",
            period=3600,  # 1 hour
            start_minutes=360  # 6 hours
        )

        # Get error metrics
        errors = get_metric(
            namespace="AWS/Lambda",
            metric_name="Errors",
            dimensions={"FunctionName": func},
            statistic="Sum",
            period=3600,
            start_minutes=360
        )

        # Get duration metrics
        duration = get_metric(
            namespace="AWS/Lambda",
            metric_name="Duration",
            dimensions={"FunctionName": func},
            statistic="Average",
            period=3600,
            start_minutes=360
        )

        total_invocations = sum(p['value'] for p in invocations['datapoints'])
        total_errors = sum(p['value'] for p in errors['datapoints'])
        avg_duration = duration['summary']['avg'] if duration['datapoints'] else 0

        # Calculate health score
        if total_invocations == 0:
            health = "IDLE"
            score = 0
        else:
            error_rate = (total_errors / total_invocations) * 100
            if error_rate == 0:
                health = "HEALTHY"
                score = 100
            elif error_rate < 1:
                health = "WARNING"
                score = 75
            else:
                health = "CRITICAL"
                score = 50

        health_data.append({
            'function': func,
            'health': health,
            'score': score,
            'invocations': total_invocations,
            'errors': total_errors,
            'duration': avg_duration,
            'error_rate': (total_errors / total_invocations * 100) if total_invocations > 0 else 0
        })

    # Sort by invocations (most active first)
    health_data.sort(key=lambda x: x['invocations'], reverse=True)

    # Print dashboard
    print(f"{'Function':<40} {'Status':<12} {'Invocations':<12} {'Errors':<8} {'Avg Duration':<12}")
    print("-" * 100)

    for item in health_data:
        func_short = item['function'][:38]

        # Status icon
        if item['health'] == "HEALTHY":
            icon = "üü¢ HEALTHY"
        elif item['health'] == "WARNING":
            icon = "üü° WARNING"
        elif item['health'] == "CRITICAL":
            icon = "üî¥ CRITICAL"
        else:
            icon = "‚ö™ IDLE"

        invoc = f"{item['invocations']:.0f}"
        errs = f"{item['errors']:.0f}"
        dur = f"{item['duration']:.0f}ms" if item['duration'] > 0 else "N/A"

        print(f"{func_short:<40} {icon:<12} {invoc:<12} {errs:<8} {dur:<12}")

        if item['error_rate'] > 0:
            print(f"  ‚îî‚îÄ Error rate: {item['error_rate']:.2f}%")

    print("\n")


def analyze_active_function():
    """Deep dive into the most active function"""

    print("=" * 80)
    print("  Deep Dive: veridano-admin-dashboard")
    print("=" * 80 + "\n")

    func = "veridano-admin-dashboard"

    # Get detailed metrics over 24 hours
    print("üìä Performance Metrics (Last 24 Hours)\n")

    invocations = get_metric(
        namespace="AWS/Lambda",
        metric_name="Invocations",
        dimensions={"FunctionName": func},
        statistic="Sum",
        period=3600,
        start_minutes=1440
    )

    duration = get_metric(
        namespace="AWS/Lambda",
        metric_name="Duration",
        dimensions={"FunctionName": func},
        statistic="Average",
        period=3600,
        start_minutes=1440
    )

    errors = get_metric(
        namespace="AWS/Lambda",
        metric_name="Errors",
        dimensions={"FunctionName": func},
        statistic="Sum",
        period=3600,
        start_minutes=1440
    )

    throttles = get_metric(
        namespace="AWS/Lambda",
        metric_name="Throttles",
        dimensions={"FunctionName": func},
        statistic="Sum",
        period=3600,
        start_minutes=1440
    )

    # Calculate totals
    total_invocations = sum(p['value'] for p in invocations['datapoints'])
    total_errors = sum(p['value'] for p in errors['datapoints'])
    total_throttles = sum(p['value'] for p in throttles['datapoints'])
    avg_duration = duration['summary']['avg']
    max_duration = duration['summary']['max']

    print(f"  Total Invocations: {total_invocations:.0f}")
    print(f"  Total Errors: {total_errors:.0f}")
    print(f"  Total Throttles: {total_throttles:.0f}")
    print(f"  Average Duration: {avg_duration:.2f}ms")
    print(f"  Max Duration: {max_duration:.2f}ms")

    if total_invocations > 0:
        success_rate = ((total_invocations - total_errors) / total_invocations) * 100
        print(f"  Success Rate: {success_rate:.2f}%")

    # Show hourly breakdown
    if invocations['datapoints']:
        print("\nüìà Hourly Activity Pattern\n")
        print(f"  {'Time':<25} {'Invocations':<12} {'Avg Duration':<15} {'Errors':<8}")
        print("  " + "-" * 60)

        # Combine datapoints by hour
        for i, inv_point in enumerate(invocations['datapoints']):
            timestamp = inv_point['timestamp']
            invoc_count = inv_point['value']

            # Find matching duration and error datapoints
            dur_value = 0
            err_value = 0

            for dur_point in duration['datapoints']:
                if dur_point['timestamp'] == timestamp:
                    dur_value = dur_point['value']
                    break

            for err_point in errors['datapoints']:
                if err_point['timestamp'] == timestamp:
                    err_value = err_point['value']
                    break

            # Format for display
            time_str = timestamp[:19].replace('T', ' ')
            invoc_str = f"{invoc_count:.0f}"
            dur_str = f"{dur_value:.1f}ms" if dur_value > 0 else "N/A"
            err_str = f"{err_value:.0f}"

            print(f"  {time_str:<25} {invoc_str:<12} {dur_str:<15} {err_str:<8}")

    # Get recent logs
    print("\nüìù Recent Log Events\n")

    logs = get_lambda_logs(
        function_name=func,
        start_minutes=120,  # 2 hours
        limit=10
    )

    if logs['total_events'] > 0:
        print(f"  Found {logs['total_events']} log events in last 2 hours")
        print(f"  Errors detected: {logs['error_count']}\n")

        for i, event in enumerate(logs['events'][:5], 1):
            timestamp = event['timestamp'].split('.')[0].replace('T', ' ')
            message = event['message'][:70] + "..." if len(event['message']) > 70 else event['message']

            # Highlight errors
            if 'ERROR' in message.upper() or 'EXCEPTION' in message.upper():
                print(f"  üî¥ [{timestamp}]")
            else:
                print(f"  üìÑ [{timestamp}]")

            print(f"     {message}\n")
    else:
        print("  No logs found in the last 2 hours")

    print()


def infrastructure_summary():
    """Overall infrastructure health summary"""

    print("=" * 80)
    print("  Infrastructure Summary")
    print("=" * 80 + "\n")

    # Get list of all functions and check their health
    import boto3
    lambda_client = boto3.client('lambda', region_name='us-east-1')

    response = lambda_client.list_functions(MaxItems=50)
    total_functions = len(response['Functions'])

    print(f"üì¶ Total Lambda Functions: {total_functions}")

    # Count active functions (invoked in last 24 hours)
    active_count = 0
    idle_count = 0
    error_count = 0

    print(f"\nüîç Scanning function health...\n")

    for func in response['Functions'][:10]:  # Check first 10
        func_name = func['FunctionName']

        metrics = get_metric(
            namespace="AWS/Lambda",
            metric_name="Invocations",
            dimensions={"FunctionName": func_name},
            statistic="Sum",
            period=86400,  # Daily
            start_minutes=1440  # 24 hours
        )

        invocations = sum(p['value'] for p in metrics['datapoints'])

        if invocations > 0:
            active_count += 1
            # Check for errors
            errors = get_metric(
                namespace="AWS/Lambda",
                metric_name="Errors",
                dimensions={"FunctionName": func_name},
                statistic="Sum",
                period=86400,
                start_minutes=1440
            )
            error_sum = sum(p['value'] for p in errors['datapoints'])
            if error_sum > 0:
                error_count += 1
        else:
            idle_count += 1

    print(f"  Active Functions (last 24h): {active_count}")
    print(f"  Idle Functions: {idle_count}")
    print(f"  Functions with Errors: {error_count}")

    if error_count > 0:
        print(f"\n  ‚ö†Ô∏è  {error_count} function(s) have errors - investigate recommended")
    else:
        print(f"\n  ‚úÖ No errors detected in active functions")

    print()


if __name__ == "__main__":
    print("\n" + "=" * 80)
    print("  StrandKit Real AWS Insights Demo")
    print("  Account: 227272756319 | Region: us-east-1")
    print("=" * 80 + "\n")

    # Run all analyses
    health_check_dashboard()
    analyze_active_function()
    infrastructure_summary()

    print("=" * 80)
    print("  Analysis Complete!")
    print("  All data retrieved using StrandKit tools üéâ")
    print("=" * 80 + "\n")
